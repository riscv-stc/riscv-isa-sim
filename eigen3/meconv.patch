commit a482942b67fac2767709745ab91905809a414b54
Author: hongfeng.chen <hongfeng.chen@streamcomputing.com>
Date:   Wed Oct 16 23:14:27 2019 -0400

    update meconv_x8/memconv_mm

diff --git a/eigen3/eigen3_ops.cc b/eigen3/eigen3_ops.cc
index dbbb19b..a439ae9 100644
--- a/eigen3/eigen3_ops.cc
+++ b/eigen3/eigen3_ops.cc
@@ -120,7 +120,7 @@ void CustomInsns::shapestride_dbg(struct ShapeStride *ss)
 int CustomInsns::meconv_mm(half *rs1, half *rd, half *rs2, struct ConvShapeStride *ss)
 {
     int pad_top, pad_bottom, pad_left, pad_right;
-    int kw, kh, k_stride, sk;
+    int kw, kh, okw, okh, k_stride, sk;
     int in_w, in_h, in_c, in_stride;
     int out_w, out_h, out_c, out_stride;
     int w, h, c;
@@ -136,49 +136,42 @@ int CustomInsns::meconv_mm(half *rs1, half *rd, half *rs2, struct ConvShapeStrid
     valid = pad_top == 0 && pad_bottom == 0 &&
             pad_left == 0 && pad_right == 0;
 
+    //get the input shape
+    in_w = (ss->conv_fm_in >> 16) & 0xffff;
+    in_h = (ss->conv_fm_in) & 0xffff;
+    in_c = (ss->conv_depth_in) & 0xffff;
+    assert(in_w > 0 && in_h > 0 && in_c > 0);
+    in_stride = (ss->conv_depth_in >> 16) & 0xffff;
+    assert((in_stride % 2) == 0); //half
+    in_stride = in_stride > 0 ? in_stride >> 1 : in_c;
+
     //get the kernel shape
     kw = (ss->conv_kernel >> 24) & 0xff;
     kh = (ss->conv_kernel >> 16) & 0xff;
     dilation = (ss->conv_kernel >> 8) & 0xff;
     sk = (ss->conv_kernel) & 0xff;
-    assert(sk > 0);
+    assert(sk > 0 && kw > 0 && kh > 0 && dilation > 0);
     k_stride = ss->conv_s_kernel & 0xffff ;
-    assert(k_stride % 2 == 0);
-    k_stride = k_stride > 0 ? k_stride >> 1 : 1;
+    assert(k_stride > 0 && k_stride % 2 == 0);
+    k_stride = k_stride >> 1;
 
-    //get the input shape
-    in_w = (ss->conv_fm_in >> 16) & 0xffff;
-    in_h = (ss->conv_fm_in) & 0xffff;
-    in_c = (ss->conv_depth_in) & 0xffff;
-    in_c = in_c > 0 ? in_c >> 1 : 1;
-    in_stride = (ss->conv_depth_in >> 16) & 0xffff;
-    assert((in_stride % 2) == 0); //half
-    in_stride = in_stride > 0 ? in_stride >> 1 : 1;
 
     //get the output shape
     out_w = (ss->conv_fm_out >> 16) & 0xffff;
     out_h = (ss->conv_fm_out) & 0xffff;
     out_c = (ss->conv_depth_out) & 0xffff;
+    assert(out_w > 0 && out_h > 0 && out_c > 0);
     out_stride = (ss->conv_depth_out >> 16) & 0xffff;
     assert(out_stride % 2 == 0);
-    out_stride = out_stride > 0 ? out_stride >> 1 : 1;
+    out_stride = out_stride > 0 ? out_stride >> 1 : out_c;
 
     /*calculate the kernel shape*/
-    dilation = dilation > 0 ? dilation : 1;
+    Map_half rs2_matrix(rs2, kh * kw * in_c, out_c, DynStride(k_stride, 1)); // the depth is same as in_c
+
     h = dilation > 1 ? dilation * (kh - 1) + 1 : kh;
     w = dilation > 1 ? dilation * (kw - 1) + 1 : kw;
-    half *kernel_dilation = (half *)malloc(h * w * in_c * sizeof(half));
-    memset(kernel_dilation, 0, h * w * in_c * sizeof(half));
-
-    Map_half rs2_matrix(rs2, kh, kw * in_c, DynStride(k_stride * kw, 1)); // the depth is same as in_c
-    Map_half kd_matrix(kernel_dilation, h, w * in_c, DynStride(in_c * w, 1));
-
-    for (i = 0; i < kh; i ++) {
-        for (j = 0; j < kw; j ++) {
-            for (k = 0; k < in_c; k ++)
-                kd_matrix(i * dilation, j * dilation * in_c + k) = rs2_matrix(i, j * in_c + k);
-        }
-    }
+    okh = kh;
+    okw = kw;
     kh = h;
     kw = w;
 
@@ -187,41 +180,110 @@ int CustomInsns::meconv_mm(half *rs1, half *rd, half *rs2, struct ConvShapeStrid
     h = in_h + (pad_top + pad_bottom);
     w = in_w + (pad_right + pad_left);
 
-    half *padding = (half *)malloc(h * w * in_c * sizeof(half));
-    memset(padding, 0, h * w * in_c * sizeof(half));
-    Map_half padding_matrix(padding, h, w * in_c, DynStride(in_c * w, 1));
-    padding_matrix.block(pad_top, pad_left * in_c, in_h, in_w * in_c) = rs1_matrix.block(0, 0, in_h, in_w * in_c);
-
     if (debug) {
         MECONV_INFO(ss);
         cout << "rs1:" << endl << rs1_matrix << endl;
-	cout << "padding_matrix:" << endl << padding_matrix << endl;
         cout << "rs2:" << endl << rs2_matrix << endl;
-	cout << "kd_matrix:" << endl << kd_matrix << endl;
     }
 
+    int ii, jj, kk;
+    half *rs1_start;
+    half *left_val;
+    half *start;
+    half val;
+
     /*calculate the output shape*/
     if (valid) {
         h = (in_h - kh + 1 + sk - 1) /sk;
         w = (in_w - kw + 1 + sk - 1) /sk;
+	left_val = (half *)malloc(h * w * okh * okw * in_c * sizeof(half));
+
+	for (i = 0; i < h; i++) {
+	    for (j = 0; j < w; j++) {
+		rs1_start = rs1 + i * sk * in_w * in_stride + j * in_stride;
+		start = left_val + i * w * okh * okw * in_c + j * okh * okw * in_c;
+		if (debug)
+		    printf("rs1 offset = %d start = %d\n", i * sk * in_w * in_stride + j * in_stride, i * w * okh * okw * in_c + j * okh * okw * in_c);
+
+		for (ii = 0; ii < kh; ii++) {
+		    for (jj = 0; jj < kw; jj ++) {
+			for (kk = 0; kk < in_c; kk ++) {
+			    if (ii % dilation)
+			        continue;
+			    else {
+			        if (jj % dilation)
+				    continue;
+				else {
+				    *(start + ii/dilation * okw * in_c + jj/dilation * in_c + kk) = *(rs1_start + ii * in_w * in_stride + jj * in_stride + kk);
+				    if (debug) {
+				        val = *(rs1_start + ii * in_w * in_stride + jj * in_stride + kk);
+				        printf("rd offset= %d val = 0x%x ",ii/dilation * okw * in_c + jj/dilation * in_c + kk, val.x);
+				        val = *(start + ii/dilation * okw * in_c + jj/dilation * in_c + kk);
+				        printf("rd val = 0x%x\n", val.x);
+				    }
+				}
+			    }
+			}//kk
+		    }//jj
+		}//ii
+	    }//j
+	}//i
     }
     else {
+	int row, col;
         h = (in_h + sk - 1) /sk;
         w = (in_w + sk - 1) /sk;
+	left_val = (half *)malloc(h * w * okh * okw * in_c * sizeof(half));
+
+	for (i = 0; i < h; i++) {
+	    for (j = 0; j < w; j++) {
+		start = left_val + i * w * okh * okw * in_c + j * okh * okw * in_c;
+		rs1_start = rs1;
+
+	        for (ii = 0; ii < kh; ii++) {
+		    for (jj = 0; jj < kw; jj++) {
+			for (kk = 0; kk < in_c; kk++) {
+			    row = i * sk + ii;
+			    col = j * sk + jj;
+
+			    if (ii % dilation)
+			        continue;
+			    else {
+			        if (jj % dilation)
+				    continue;
+				else {
+				    if (row >= pad_top && row < pad_top + in_h && col >= pad_left && col < pad_left + in_w) {
+				        *(start + ii/dilation * okw * in_c + jj/dilation * in_c + kk) = *(rs1_start + (row - pad_top) * in_w * in_stride + (col - pad_left) * in_stride + kk);
+				        val = *(rs1_start + (row - pad_top) * in_w * in_stride + (col - pad_left) * in_stride + kk);
+				    }
+				    else {
+				        *(start + ii/dilation * okw * in_c + jj/dilation * in_c + kk) = (half)0;
+					val =  (half)0;
+				    }
+				    if (debug) {
+				        printf("rd offset= %d val = 0x%x ",ii/dilation * okw * in_c + jj/dilation * in_c + kk, val.x);
+				        val = *(start + ii/dilation * okw * in_c + jj/dilation * in_c + kk);
+				        printf("rd val = 0x%x\n", val.x);
+				    }
+				}
+			    }
+			}//kk
+		    }//jj
+		}//ii
+	    }//j
+	}//i
+
     }
 
     /*param check*/
     printf("h = %d w = %d out_h = %d out_w = %d\n", h, w, out_h, out_w);
     assert(h == out_h && w == out_w);
 
+
     /*calculate convolution*/
-    Map_half rd_matrix(rd, out_h, out_w * out_c, DynStride(out_stride * out_w, 1));
-    for (i = 0; i < out_h; i++) {
-        for (j = 0; j < out_w; j++) {
-            rd_matrix(i, j) = (padding_matrix.block(i * sk, j * sk * in_c, kh, kw * in_c).array() *
-			       kd_matrix.array()).sum();
-        }
-    }
+    Map_half left_matrix(left_val, h * w, okh * okw * in_c, DynStride(okh * okw * in_c, 1));
+    Map_half rd_matrix(rd, out_h * out_w, out_c, DynStride(out_stride, 1));
+    rd_matrix = left_matrix * rs2_matrix;
 
     if (debug)
         cout << "rd:" << endl << rd_matrix << endl;
@@ -242,7 +304,7 @@ int CustomInsns::meconv_mm(half *rs1, half *rd, half *rs2, struct ConvShapeStrid
 int CustomInsns::meconv_x8_mm(const int8_t *rs1, int32_t *rd, const int8_t *rs2, struct ConvShapeStride *ss)
 {
     int pad_top, pad_bottom, pad_left, pad_right;
-    int kw, kh, k_stride, sk;
+    int kw, kh, okw, okh, k_stride, sk;
     int in_w, in_h, in_c, in_stride;
     int out_w, out_h, out_c, out_stride;
     int w, h, c;
@@ -258,46 +320,40 @@ int CustomInsns::meconv_x8_mm(const int8_t *rs1, int32_t *rd, const int8_t *rs2,
     valid = pad_top == 0 && pad_bottom == 0 &&
             pad_left == 0 && pad_right == 0;
 
+    //get the input shape
+    in_w = (ss->conv_fm_in >> 16) & 0xffff;
+    in_h = (ss->conv_fm_in) & 0xffff;
+    in_c = (ss->conv_depth_in) & 0xffff;
+    assert(in_w > 0 && in_h > 0 && in_c > 0);
+    in_stride = (ss->conv_depth_in >> 16) & 0xffff;
+    in_stride = in_stride > 0 ? in_stride : in_c;
+
     //get the kernel shape
     kw = (ss->conv_kernel >> 24) & 0xff;
     kh = (ss->conv_kernel >> 16) & 0xff;
     dilation = (ss->conv_kernel >> 8) & 0xff;
     sk = (ss->conv_kernel) & 0xff;
-    assert(sk > 0);
+    assert(sk > 0 && kw > 0 && kh > 0 && dilation > 0);
     k_stride = ss->conv_s_kernel & 0xffff ;
-    k_stride = k_stride > 0 ? k_stride : 1;
+    assert(k_stride > 0);
 
-    //get the input shape
-    in_w = (ss->conv_fm_in >> 16) & 0xffff;
-    in_h = (ss->conv_fm_in) & 0xffff;
-    in_c = (ss->conv_depth_in) & 0xffff;
-    in_c = in_c > 0 ? in_c : 1;
-    in_stride = (ss->conv_depth_in >> 16) & 0xffff;
-    in_stride = in_stride > 0 ? in_stride : 1;
 
     //get the output shape
     out_w = (ss->conv_fm_out >> 16) & 0xffff;
     out_h = (ss->conv_fm_out) & 0xffff;
     out_c = (ss->conv_depth_out) & 0xffff;
+    assert(out_w > 0 && out_h > 0 && out_c > 0);
     out_stride = (ss->conv_depth_out >> 16) & 0xffff;
-    out_stride = out_stride > 0 ? out_stride >> 2 : 1;
+    assert(out_stride % 4 == 0);
+    out_stride = out_stride > 0 ? out_stride >> 2 : out_c;
 
     /*calculate the kernel shape*/
-    dilation = dilation > 0 ? dilation : 1;
+    Map_int8_t rs2_matrix(rs2, kh * kw * in_c, out_c, DynStride(k_stride, 1)); // the depth is same as in_c
+
     h = dilation > 1 ? dilation * (kh - 1) + 1 : kh;
     w = dilation > 1 ? dilation * (kw - 1) + 1 : kw;
-    int8_t *kernel_dilation = (int8_t *)malloc(h * w * in_c * sizeof(int8_t));
-    memset(kernel_dilation, 0, h * w * in_c * sizeof(int8_t));
-
-    Map_int8_t rs2_matrix(rs2, kh, kw * in_c, DynStride(k_stride * kw, 1)); // the depth is same as in_c
-    Map_int8_t kd_matrix(kernel_dilation, h, w * in_c, DynStride(in_c * w, 1));
-
-    for (i = 0; i < kh; i ++) {
-        for (j = 0; j < kw; j ++) {
-            for (k = 0; k < in_c; k ++)
-                kd_matrix(i * dilation, j * dilation * in_c + k) = rs2_matrix(i, j * in_c + k);
-        }
-    }
+    okh = kh;
+    okw = kw;
     kh = h;
     kw = w;
 
@@ -306,27 +362,99 @@ int CustomInsns::meconv_x8_mm(const int8_t *rs1, int32_t *rd, const int8_t *rs2,
     h = in_h + (pad_top + pad_bottom);
     w = in_w + (pad_right + pad_left);
 
-    int8_t *padding = (int8_t *)malloc(h * w * in_c * sizeof(int8_t));
-    memset(padding, 0, h * w * in_c * sizeof(int8_t));
-    Map_int8_t padding_matrix(padding, h, w * in_c, DynStride(in_c * w, 1));
-    padding_matrix.block(pad_top, pad_left * in_c, in_h, in_w * in_c) = rs1_matrix.block(0, 0, in_h, in_w * in_c);
-
     if (debug) {
         MECONV_INFO(ss);
         cout << "rs1:" << endl << rs1_matrix.cast<int32_t>() << endl;
-	cout << "padding_matrix:" << endl << padding_matrix.cast<int32_t>() << endl;
         cout << "rs2:" << endl << rs2_matrix.cast<int32_t>() << endl;
-	cout << "kd_matrix:" << endl << kd_matrix.cast<int32_t>() << endl;
     }
 
+    int ii, jj, kk;
+    int8_t *rs1_start;
+    int8_t *left_val;
+    int8_t *start;
+    int8_t val;
+
     /*calculate the output shape*/
     if (valid) {
         h = (in_h - kh + 1 + sk - 1) /sk;
         w = (in_w - kw + 1 + sk - 1) /sk;
+	left_val = (int8_t *)malloc(h * w * okh * okw * in_c * sizeof(int8_t));
+
+	for (i = 0; i < h; i++) {
+	    for (j = 0; j < w; j++) {
+		rs1_start = rs1 + i * sk * in_w * in_stride + j * in_stride;
+		start = left_val + i * w * okh * okw * in_c + j * okh * okw * in_c;
+		if (debug)
+		    printf("rs1 offset = %d start = %d\n", i * sk * in_w * in_stride + j * in_stride, i * w * okh * okw * in_c + j * okh * okw * in_c);
+
+		for (ii = 0; ii < kh; ii++) {
+		    for (jj = 0; jj < kw; jj ++) {
+			for (kk = 0; kk < in_c; kk ++) {
+			    if (ii % dilation)
+			        continue;
+			    else {
+			        if (jj % dilation)
+				    continue;
+				else {
+				    *(start + ii/dilation * okw * in_c + jj/dilation * in_c + kk) = *(rs1_start + ii * in_w * in_stride + jj * in_stride + kk);
+				    if (debug) {
+				        val = *(rs1_start + ii * in_w * in_stride + jj * in_stride + kk);
+				        printf("rd offset= %d val = 0x%x ",ii/dilation * okw * in_c + jj/dilation * in_c + kk, val);
+				        val = *(start + ii/dilation * okw * in_c + jj/dilation * in_c + kk);
+				        printf("rd val = 0x%x\n", val);
+				    }
+				}
+			    }
+			}//kk
+		    }//jj
+		}//ii
+	    }//j
+	}//i
     }
     else {
+	int row, col;
         h = (in_h + sk - 1) /sk;
         w = (in_w + sk - 1) /sk;
+	left_val = (int8_t *)malloc(h * w * okh * okw * in_c * sizeof(int8_t));
+
+	for (i = 0; i < h; i++) {
+	    for (j = 0; j < w; j++) {
+		start = left_val + i * w * okh * okw * in_c + j * okh * okw * in_c;
+		rs1_start = rs1;
+
+	        for (ii = 0; ii < kh; ii++) {
+		    for (jj = 0; jj < kw; jj++) {
+			for (kk = 0; kk < in_c; kk++) {
+			    row = i * sk + ii;
+			    col = j * sk + jj;
+
+			    if (ii % dilation)
+			        continue;
+			    else {
+			        if (jj % dilation)
+				    continue;
+				else {
+				    if (row >= pad_top && row < pad_top + in_h && col >= pad_left && col < pad_left + in_w) {
+				        *(start + ii/dilation * okw * in_c + jj/dilation * in_c + kk) = *(rs1_start + (row - pad_top) * in_w * in_stride + (col - pad_left) * in_stride + kk);
+				        val = *(rs1_start + (row - pad_top) * in_w * in_stride + (col - pad_left) * in_stride + kk);
+				    }
+				    else {
+				        *(start + ii/dilation * okw * in_c + jj/dilation * in_c + kk) = 0;
+					val =  0;
+				    }
+				    if (debug) {
+				        printf("rd offset= %d val = 0x%x ",ii/dilation * okw * in_c + jj/dilation * in_c + kk, val);
+				        val = *(start + ii/dilation * okw * in_c + jj/dilation * in_c + kk);
+				        printf("rd val = 0x%x\n", val);
+				    }
+				}
+			    }
+			}//kk
+		    }//jj
+		}//ii
+	    }//j
+	}//i
+
     }
 
     /*param check*/
@@ -334,13 +462,9 @@ int CustomInsns::meconv_x8_mm(const int8_t *rs1, int32_t *rd, const int8_t *rs2,
     assert(h == out_h && w == out_w);
 
     /*calculate convolution*/
-    Map_int32_t rd_matrix(rd, out_h, out_w * out_c, DynStride(out_stride * out_w, 1));
-    for (i = 0; i < out_h; i++) {
-        for (j = 0; j < out_w; j++) {
-            rd_matrix(i, j) = (padding_matrix.block(i * sk, j * sk * in_c, kh, kw * in_c).array().cast<int32_t>() *
-			       kd_matrix.array().cast<int32_t>()).cast<int32_t>().sum();
-        }
-    }
+    Map_int8_t left_matrix(left_val, h * w, okh * okw * in_c, DynStride(okh * okw * in_c, 1));
+    Map_int32_t rd_matrix(rd, out_h * out_w, out_c, DynStride(out_stride, 1));
+    rd_matrix = left_matrix.cast<int32_t>() * rs2_matrix.cast<int32_t>();
 
     if (debug)
         cout << "rd:" << endl << rd_matrix << endl;
